// Hack for windows and swig
%begin %{
#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
#include <crtdefs.h>
#endif
%}

%define MODULEIMPORT
"
import $module
"
%enddef


%module(moduleimport=MODULEIMPORT, directors=1) fast
%{


#include <FAST/Object.hpp>
#include <FAST/ProcessObject.hpp>
#include <FAST/Reporter.hpp>
#include <FAST/Visualization/SimpleWindow.hpp>
#include <FAST/Visualization/View.hpp>
#include <FAST/Visualization/Renderer.hpp>
#include <FAST/Data/DataTypes.hpp>
@PYFAST_HEADER_INCLUDES@

using namespace fast;
#undef slots

%}

// General exception handler to avoid crashing python when something in FAST triggers an exception
%exception {
    try {
        $action
    } catch(std::exception &e) {
        PyErr_SetString(PyExc_RuntimeError, e.what());
        SWIG_fail;
    }
}

// Third party stuff
%include <std_string.i>
%include <std_shared_ptr.i>
%include <std_vector.i>
%include <std_map.i>
%include <FAST/Python/std_unique_ptr.i>

// Enable eigen <-> numpy data conversion
%include <FAST/Python/eigen.i>
%eigen_typemaps(Vector2f)
%eigen_typemaps(Vector3f)
%eigen_typemaps(Vector2i)
%eigen_typemaps(Vector3i)
%eigen_typemaps(Vector2ui)
%eigen_typemaps(Vector3ui)
%eigen_typemaps(VectorXf)
%eigen_typemaps(VectorXi)
%eigen_typemaps(VectorXui)
%eigen_typemaps(Matrix3f)
%eigen_typemaps(Matrix4f)


// Define FAST_EXPORT to nothing to avoid compile errors
%define FAST_EXPORT
%enddef
%define Q_OBJECT
%enddef
%define Q_SLOTS
%enddef
%define Q_SIGNALS
public
%enddef

// Enable std::vector and std::map <-> python conversion
%include <FAST/Data/DataTypes.hpp>
%template(vectori) std::vector<int>;
%template(vectorf) std::vector<float>;
%template(vectorui) std::vector<uint>;
%template(vectorc) std::vector<char>;
%template(vectoruc) std::vector<uchar>;
%template(vectors) std::vector<std::string>;
%ignore std::vector<fast::NeuralNetworkNode>::vector(size_type);
%ignore std::vector<fast::NeuralNetworkNode>::resize;
%ignore std::vector<fast::NeuralNetworkNode>::pop;
%template(NeuralNetworkNodes) std::vector<fast::NeuralNetworkNode>;
%template(ColorMap) std::map<uint, fast::Color>;
%template(LabelNames) std::map<uint, std::string>;
// This avoids the no default constructor available problem for this vector types:
%ignore std::vector<fast::MeshVertex>::vector(size_type);
%ignore std::vector<fast::MeshVertex>::resize;
%ignore std::vector<fast::MeshVertex>::pop;
%ignore std::vector<fast::MeshLine>::vector(size_type);
%ignore std::vector<fast::MeshLine>::resize;
%ignore std::vector<fast::MeshLine>::pop;
%ignore std::vector<fast::MeshTriangle>::vector(size_type);
%ignore std::vector<fast::MeshTriangle>::resize;
%ignore std::vector<fast::MeshTriangle>::pop;
%template(vectormeshvertex) std::vector<fast::MeshVertex>;
%template(vectormeshline) std::vector<fast::MeshLine>;
%template(vectormeshtriangle) std::vector<fast::MeshTriangle>;

// FAST CORE LIBRARY



// Ignore statements
%ignore getDevice;
%ignore ReporterEnd::~ReporterEnd();
%ignore QObject;
%ignore MovieStreamerWorker;
%ignore CameraWorker;
%ignore ImagePyramidLevel;
%ignore ImagePyramidPatch;
%ignore fast::ImagePyramidAccess::getPatchData;
%ignore fast::ImagePyramidAccess::getPatch;
%ignore fast::Tensor::create(std::unique_ptr<float[]> data, TensorShape shape);

%nodefaultdtor Config;

// unique_ptr declerations
%unique_ptr(fast::OpenCLImageAccess)
%unique_ptr(fast::ImageAccess)
%unique_ptr(fast::OpenCLBufferAccess)
%unique_ptr(fast::BoundingBoxSetAccess)
%unique_ptr(fast::BoundingBoxSetOpenGLAccess)
%unique_ptr(fast::MeshAccess)
%unique_ptr(fast::VertexBufferObjectAccess)
%unique_ptr(fast::MeshOpenCLAccess)
%unique_ptr(fast::TensorAccess)
%unique_ptr(fast::ImagePyramidAccess)
%unique_ptr(fast::OpenGLTextureAccess)

// Shared_ptr declerations
%shared_ptr(fast::Object)
%shared_ptr(fast::DataChannel)
%shared_ptr(fast::ExecutionDevice)
%shared_ptr(fast::Host)
%shared_ptr(fast::OpenCLDevice)
%shared_ptr(fast::RuntimeMeasurement)
%shared_ptr(fast::RuntimeMeasurementsManager)
%shared_ptr(fast::DataObject)
%shared_ptr(fast::SpatialDataObject)
%shared_ptr(fast::DataChannel)
%shared_ptr(fast::ProcessObject)
@PYFAST_SHARED_PTR_DEFS@

// These must live here due to the shared_ptr
%template(vectorrenderer) std::vector<std::shared_ptr<fast::Renderer>>;
%template(vectorpo) std::vector<std::shared_ptr<fast::ProcessObject>>;

// Interface includes
%include <FAST/Reporter.hpp>
%include <FAST/Object.hpp>
%include <FAST/Data/DataObject.hpp>
%include <FAST/DataChannels/DataChannel.hpp>
%include <FAST/DeviceCriteria.hpp>
%include <FAST/DataChannels/DataChannel.hpp>
%include <FAST/RuntimeMeasurement.hpp>
%include <FAST/RuntimeMeasurementManager.hpp>
%include <FAST/ExecutionDevice.hpp>
%include <FAST/Attribute.hpp>
%include <FAST/ProcessObject.hpp>
%include <FAST/Config.hpp>
%include <FAST/Data/Access/Access.hpp>
%include <FAST/Data/Color.hpp>
%include <FAST/Data/DataObject.hpp>
%include <FAST/Data/SpatialDataObject.hpp>
%include <FAST/Data/SimpleDataObject.hpp>
%include <FAST/Data/Access/OpenCLImageAccess.hpp>
%include <FAST/Data/Access/OpenCLBufferAccess.hpp>
%include <FAST/Data/Access/ImageAccess.hpp>
%include <FAST/Data/Access/BoundingBoxSetAccess.hpp>
%include <FAST/Data/Access/OpenGLTextureAccess.hpp>
%include <FAST/Visualization/Plane.hpp>

@PYFAST_INTERFACE_INCLUDES@

%define ADD_TEMPLATE_METHODS(TYPE)
%template(updateAndGetOutput ## TYPE) fast::ProcessObject::updateAndGetOutputData<fast::TYPE>;
%template(getNext ## TYPE) fast::DataChannel::getNextFrame<fast::TYPE>;
%{
std::shared_ptr<fast::TYPE> convertDataObjectTo##TYPE(std::shared_ptr<fast::DataObject> dataObject) {
    return std::dynamic_pointer_cast<fast::TYPE>(dataObject);
}
%}
std::shared_ptr<fast::TYPE> convertDataObjectTo##TYPE(std::shared_ptr<fast::DataObject> dataObject);
%enddef



ADD_TEMPLATE_METHODS(Image)
ADD_TEMPLATE_METHODS(ImagePyramid)
ADD_TEMPLATE_METHODS(Segmentation)
ADD_TEMPLATE_METHODS(Tensor)
ADD_TEMPLATE_METHODS(Mesh)
ADD_TEMPLATE_METHODS(BoundingBox)
ADD_TEMPLATE_METHODS(BoundingBoxSet)
ADD_TEMPLATE_METHODS(Text)
%template(getNextFrame) fast::DataChannel::getNextFrame<fast::DataObject>;

// Extend image for numpy support
%extend fast::Image {
std::size_t _getHostDataPointer() {
    auto access = $self->getImageAccess(ACCESS_READ);
    return (std::size_t)access->get();
}
static void* _intToVoidPointer(std::size_t intPointer) {
    return (void*)intPointer;
}
%pythoncode %{
  _data_type_to_str = {
    TYPE_UINT8: 'u1',
    TYPE_INT8: 'i1',
    TYPE_UINT16: 'u2',
    TYPE_INT16: 'i2',
    TYPE_FLOAT: 'f4',
  }
  _str_to_data_type = {value : key for (key, value) in _data_type_to_str.items()}
  @property
  def __array_interface__(self):
    if self.getDimensions() == 2:
        shape = (self.getHeight(), self.getWidth(), self.getNrOfChannels())
    else:
        shape = (self.getDepth(), self.getHeight(), self.getWidth(), self.getNrOfChannels())
    return {
      'shape': shape,
      'data': (self._getHostDataPointer(), False),
      'typestr': self._data_type_to_str[self.getDataType()],
      'version': 3,
      'strides': None,
    }

  @staticmethod
  def createFromArray(ndarray):
    """Create a FAST image from a N-D array (e.g. numpy ndarray)"""
    if not hasattr(ndarray, '__array_interface__'):
        raise ValueError('Input to Image createFromArray() must have the array_interface property')
    array_interface = ndarray.__array_interface__
    shape = array_interface['shape']
    is_2d = True
    has_channels = False
    if len(shape) > 2 and shape[-1] <= 4:
        has_channels = True
    elif len(shape) == 3 and shape[-1] > 4:
        is_2d = False
    elif len(shape) > 3:
        is_2d = False
        has_channels = True
    if is_2d:
        return Image.create(
            shape[1],
            shape[0],
            Image._str_to_data_type[array_interface['typestr'][1:]],
            shape[-1] if has_channels else 1,
            Image._intToVoidPointer(array_interface['data'][0])
        )
    else:
        return Image.create(
            shape[2],
            shape[1],
            shape[0],
            Image._str_to_data_type[array_interface['typestr'][1:]],
            shape[-1] if has_channels else 1,
            Image._intToVoidPointer(array_interface['data'][0])
        )
%}
}

// Extend Tensor for numpy support
%extend fast::Tensor {
std::size_t _getHostDataPointer() {
    auto access = $self->getAccess(ACCESS_READ);
    return (std::size_t)access->getRawData();
}
static float* _intToFloatPointer(std::size_t intPointer) {
    return (float*)intPointer;
}
%pythoncode %{
  @property
  def __array_interface__(self):
    return {
      'shape': self.getShape().getAll(),
      'data': (self._getHostDataPointer(), False),
      'typestr': 'f4',
      'version': 3,
      'strides': None,
    }

  @staticmethod
  def createFromArray(ndarray):
    """Create a FAST Tensor from a N-D array (e.g. numpy ndarray)"""
    if not hasattr(ndarray, '__array_interface__'):
        raise ValueError('Input to Tensor createFromArray() must have the array_interface property')
    array_interface = ndarray.__array_interface__
    # Check data type if it is correct
    if array_interface['typestr'] != 'f4':
      import numpy as np
      # Convert if numpy, else raise error
      if isinstance(ndarray, np.ndarray):
        print('WARNING: ndarray given to fast::Tensor::createFromArray was not 32 bit float and will now be converted.')
        ndarray = ndarray.astype(np.float32)
        array_interface = ndarray.__array_interface__
      else:
        raise ValueError('Array given to Tensor::createFromArray must be 32 bit float, but you sent ' + array_interface['typestr'])
    shape = array_interface['shape']
    fast_shape = TensorShape()
    for i in shape:
        fast_shape.addDimension(i)

    return Tensor.create(Tensor._intToFloatPointer(array_interface['data'][0]), fast_shape)
%}
}

// Python process object functionality using directors feature

%feature("director") PythonProcessObject;
%shared_ptr(fast::PythonProcessObject)

%inline %{

#define ADD_GET_INPUT_DATA_METHOD(TYPE)                     \
    std::shared_ptr<TYPE> getInput ## TYPE (int port = 0) {  \
        return ProcessObject::getInputData<TYPE>(port);   \
    };                                                      \

namespace fast {
    class PythonProcessObject : public ProcessObject {
    public:
        virtual void execute() = 0;
        std::string getNameOfClass() const {
            return "PythonProcessObject";
        }
        virtual ~PythonProcessObject() { };
        std::shared_ptr<PythonProcessObject> m_hack;
        PythonProcessObject() {
            // A hack to make this work as PythonProcessObject does not return a smart pointer thread New as other POs.
            // Use a custom deleter which doesn't delete to avoid double delete
            m_hack.reset(this, [](PythonProcessObject* obj) {});
            mPtr = m_hack;
        }

        void setInputConnection(DataChannel::pointer port) {
            ProcessObject::setInputConnection(0, port);
        }

        void setInputConnection(uint portID, DataChannel::pointer port) {
            ProcessObject::setInputConnection(portID, port);
        }

        DataChannel::pointer getOutputPort(uint portID = 0) {
            return ProcessObject::getOutputPort(portID);
        }

        ADD_GET_INPUT_DATA_METHOD(Image)
        ADD_GET_INPUT_DATA_METHOD(ImagePyramid)
        ADD_GET_INPUT_DATA_METHOD(Segmentation)
        ADD_GET_INPUT_DATA_METHOD(Tensor)
        ADD_GET_INPUT_DATA_METHOD(Mesh)
        ADD_GET_INPUT_DATA_METHOD(BoundingBox)
        ADD_GET_INPUT_DATA_METHOD(BoundingBoxSet)
        ADD_GET_INPUT_DATA_METHOD(Text)

        void addOutputData(int port, std::shared_ptr<DataObject> image) {
            ProcessObject::addOutputData(port, image);
        }

        void createInputPort(int port) {
            ProcessObject::createInputPort<DataObject>(port);
        }
        void createOutputPort(int port) {
            ProcessObject::createOutputPort<DataObject>(port);
        }

    }; // end class python process object
} // end namespace
%}

// Convienience method for PythonProcessObject. Static method New makes it similar to other POs
%extend fast::PythonProcessObject {

%pythoncode %{
@classmethod
def create(cls, *args, **kwargs):
    instance = cls(*args, **kwargs)
    return instance

def connect(self, *args):
    inputPortID = 0
    outputPortID = 0
    if len(args) == 1:
        parentProcessObject = args[0]
    elif len(args) == 2:
        if isinstance(args[0], int):
            inputPortID = int(args[0])
            parentProcessObject = args[1]
        else:
            parentProcessObject = args[0]
            outputPortID = int(args[1])
    elif len(args) == 3:
        inputPortID = int(args[0])
        parentProcessObject = args[1]
        outputPortID = int(args[2])
    else:
        raise TypeError("Incorrect arguemnts to connect()")

    super().connect(inputPortID, parentProcessObject, outputPortID)
    return self

%}
}



// Get proper error messages if python error occurs in PythonProcessObject director
// This was taken from https://github.com/swig/swig/issues/1117
%feature("director:except") {
    if($error != NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_NormalizeException(&exc, &val, &tb);
        std::string err_msg("In method '$symname': ");

        PyObject* exc_str = PyObject_GetAttrString(exc, "__name__");
        err_msg += SWIG_Python_str_AsChar(exc_str);
        Py_XDECREF(exc_str);

        if(val != NULL) {
            PyObject* val_str = PyObject_Str(val);
            err_msg += ": ";
            err_msg += SWIG_Python_str_AsChar(val_str);
            Py_XDECREF(val_str);
        }

        Py_XDECREF(exc);
        Py_XDECREF(val);
        Py_XDECREF(tb);

        Swig::DirectorMethodException::raise(err_msg.c_str());
    }
}

// DataStream iterable
%pythoncode "@PROJECT_SOURCE_DIR@/source/FAST/Python/DataStream.py"

%extend fast::ProcessObject {
%pythoncode %{
   def getDataStream(self):
       return DataStream(self)
%}
}

